DESIGN PRINCIPLES
_________________

Methods defined in a class represents the behaviour that instances of that class will have during runtime.
Associations deifne a relationship between classes. There are multiple types of association - 

Dependeny Association - 

public class Vehicle{
  public void break() {
    Syso("break");
  }
  
   public void run() {
    Syso("run");
  }
}

public class Driver{
  public void drive(Vehicle car)  { //Driver recieves Vehicle object only in scope of drive(), Driver is dependent on Vehicle to perform drive()
    car.run();
  }
}


Composition Association- A particular object is composed of other objects. Composition implies ownership. If the containing object ceases to exist, then
internal objects which are part of it ceases to exist. 

public class Vehicle{

  Tyre tyre; //Vehicle has composition association with Tyre, if vehicle ceases to exist so does Tyre;
  public vehicle(Tyre aTyreObj) {
    tyre = aTyreObj;
  }
}


Aggregation Association - It does not apply ownership unlike composition. It is less restricted form of Composition where entities can remain alive even
if one ceases to exist

public class HistoryCourse {
  Student[] registeredStudents;
}

FORMING ASSOCIATIONS B/W OBECTS
_______________________________

When thinking about forming association b/w objects, do not only think about how objects behaviour, but also about your application behaviour 

SOFTWARE DESIGNS (SOLID princilples)
___________________________________

SINGLE Responsibilty Principles(S) - A class should only know about one thing 

Opne closed principle(O) - software modules like classes, methods, entities should be open for extension and closed for modification. New functionality should
have minimum changes to already working and tested code. Cohesion is keeping related classes in same package.


Liskov substituion principle- subtypes must be substitubale for their basetypes.  The Liskov Substitution principle states,
that child classes should not be substitutable in place of their parents. If we try to make a child class which cannot be truly substituable by base class, then
we are breaking LSP rule. In that case we can use interfaces. For exa- if I have a class named Employee which is extended by QA, SDE, BA which have certain
set of responsbility like comeToOffice(), work(), meeting(). This is following LSP. Now a new class come into picture named- 'RemoteWorker' which will
need methods like work(), meeting() but not comeToOffice(). In this case if we make Employee class as parent of RemoteWorker then it will break the LSP rule
as it really does't need comeToOffice(). To overcome this, we can proabably remove comeToOffice() from Employee class and use interface named workInOffice
and use it to implemented by QA,SDE, BA but not RemoteWorker. This way LSP is not broken.


Interface Segregation Principle- If a module does not use functionality from another module, 
there is no reason to have a direct dependency between them. There should be an abstraction in between to segregate the 2 modules. Exa-


public class CustomerTransaction {
	public String getName() {
		return "Levis";
	}
	
	public String getDate() {
		return "12th July";
	}
	
	public String getProduct(){
		return "shirt";
	}
	
	public String getInvoice() {
		return "invoice";
	}
}


public class CustomerProductInfo {
	CustomerTransaction customerTransaction;
	
	public void getProductInfo() {
		customerTransaction.getName();
		customerTransaction.getProduct();
	}
}

Here we can see, CustomerProductInfo needs only 2 methods from CustomerTransaction, and it is dependent upon CustomerTransaction object, if anything
changes in CustomerTransaction which might not be even relevant to CustomerProductInfo, CustomerProductInfo will have to recompile and has dependency on it;
Better aproach would be- 


public interface CustomerInfoInterface {
	public String getProduct();
	public String getName() ;
}


public class CustomerProductInfo {
	CustomerInfoInterface customerTransaction; //here you can see we dont need CustomerTransaction object anymore, and we can use interface to interact
	
	public void getProductInfo() {
		customerTransaction.getName();
		customerTransaction.getProduct();
	}
}

public class CustomerTransaction implements CustomerInfoInterface{
	public String getName() {
		return "Levis";
	}
	
	public String getDate() {
		return "12th July";
	}
	
	public String getProduct(){
		return "shirt";
	}
	
	public String getInvoice() {
		return "invoice";
	}
}




Dependency Inversion principle and template pattern(D) - Concrete classes shoudld depend on interfaces and abstarct classes because they change less often 
are high level modules. High level modules should not depend upon low level modules, and both high level modules and low level modules should 
depend upon abstraction.  Abstract classes and interfaces dont change as often as concreted derivatives.  Abstract classes and interfaces define a contract for 
their derivatives.

example of template pattern
public abstract class Electronic {
	private String name;
	
	public Electronic(String name) {
		super();
		this.name = name;
	}
	protected abstract void assembly();
	protected abstract void pack();
	protected abstract void store();
	
	
	//this is called template method design pattern, used in making common workflows for various objects
	//Methods are implemented in subclasses, but called from abstract class.
	public void launch() {
		if(name!= null && !name.isEmpty()) {
			assembly();
			pack();
			store();
		}
	}
}



OOP DESIGN PATTERNS 
_________________

Dependency Injection - 

Observer Pattern - Is used to notify objects of state changes. The observer pattern is a software design pattern in which an object,
named the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes,
usually by calling one of their methods.
It is mainly used for implementing distributed event handling systems, in "event driven" software. 
In those systems, the subject is usually named a "stream of events" or "stream source of events", while the observers are 
called "sinks of events". The stream nomenclature alludes to a physical setup where the observers are physically separated
and have no control over the emitted events from the subject/stream-source. 
This pattern then perfectly suits any process where data arrives from some input that is not 
available to the CPU at startup, but instead arrives "at random" (HTTP requests, GPIO data, user input
from keyboard/mouse/..., distributed databases and blockchains, ...). Most modern programming-languages c
omprise built-in "event" constructs implementing the observer-pattern components. While not mandatory, most 'observers' 
implementations would use background threads listening for subject-events and other support mechanisms provided by the kernel

Strategy Pattern - 

Template pattern- 

